;  LST file generated by mikroListExporter - v.2.0 
; Date/Time: 14-Mar-18 5:32:13 PM
;----------------------------------------------

;Address Opcode 	ASM
0x0000	0x2970      	GOTO       368
_interrupt:
0x0004	0x0870      	MOVF       R0, 0
0x0005	0x0020      	MOVLB      0
0x0006	0x00A1      	MOVWF      33
0x0007	0x0871      	MOVF       R1, 0
0x0008	0x00A0      	MOVWF      32
0x0009	0x018A      	CLRF       PCLATH
0x000A	0x0183      	CLRF       STATUS
;Controlador5A.c,71 :: 		void interrupt()
;Controlador5A.c,73 :: 		if(TMR1IF_bit)            //interrupcao pelo estouro do Timer1
0x000B	0x1C11      	BTFSS      TMR1IF_bit, 0
0x000C	0x2811      	GOTO       L_interrupt12
;Controlador5A.c,75 :: 		TMR1IF_bit = 0;          //Limpa a flag de interrupcao
0x000D	0x1011      	BCF        TMR1IF_bit, 0
;Controlador5A.c,76 :: 		n_interrupts_timer1++;   //incrementa a flag do overflow do timer1
0x000E	0x0AA2      	INCF       _n_interrupts_timer1, 1
0x000F	0x1903      	BTFSC      STATUS, 2
0x0010	0x0AA3      	INCF       _n_interrupts_timer1+1, 1
;Controlador5A.c,77 :: 		}
L_interrupt12:
;Controlador5A.c,79 :: 		if(CCP3IF_bit && CCP3CON.B0)            //Interrupcao do modulo CCP3 e modo de captura configurado para borda de subida?
0x0011	0x1E13      	BTFSS      CCP3IF_bit, 4
0x0012	0x2829      	GOTO       L_interrupt15
0x0013	0x0026      	MOVLB      6
0x0014	0x1C13      	BTFSS      CCP3CON, 0
0x0015	0x2829      	GOTO       L_interrupt15
L__interrupt53:
;Controlador5A.c,81 :: 		CCP3IF_bit  = 0x00;                    //Limpa a flag para nova captura
0x0016	0x0020      	MOVLB      0
0x0017	0x1213      	BCF        CCP3IF_bit, 4
;Controlador5A.c,82 :: 		CCP3IE_bit  = 0x00;                    //Desabilita interrupcao do periferico CCP
0x0018	0x0021      	MOVLB      1
0x0019	0x1213      	BCF        CCP3IE_bit, 4
;Controlador5A.c,83 :: 		CCP3CON     = 0x04;                    //Configura captura por borda de descida
0x001A	0x3004      	MOVLW      4
0x001B	0x0026      	MOVLB      6
0x001C	0x0093      	MOVWF      CCP3CON
;Controlador5A.c,84 :: 		t1_sig1     = micros();                //Guarda o valor do timer1 da primeira captura.
0x001D	0x2157      	CALL       _micros
0x001E	0x0870      	MOVF       R0, 0
0x001F	0x00B0      	MOVWF      _t1_sig1
0x0020	0x0871      	MOVF       R1, 0
0x0021	0x00B1      	MOVWF      _t1_sig1+1
0x0022	0x0872      	MOVF       R2, 0
0x0023	0x00B2      	MOVWF      _t1_sig1+2
0x0024	0x0873      	MOVF       R3, 0
0x0025	0x00B3      	MOVWF      _t1_sig1+3
;Controlador5A.c,85 :: 		CCP3IE_bit  = 0x01;                    //Habilita interrupcao do periferico CCP
0x0026	0x0021      	MOVLB      1
0x0027	0x1613      	BSF        CCP3IE_bit, 4
;Controlador5A.c,86 :: 		} //end if
0x0028	0x284E      	GOTO       L_interrupt16
L_interrupt15:
;Controlador5A.c,87 :: 		else if(CCP3IF_bit)                     //Interrupcao do modulo CCP3?
0x0029	0x0020      	MOVLB      0
0x002A	0x1E13      	BTFSS      CCP3IF_bit, 4
0x002B	0x284E      	GOTO       L_interrupt17
;Controlador5A.c,89 :: 		CCP3IF_bit  = 0x00;                    //Limpa a flag para nova captura
0x002C	0x1213      	BCF        CCP3IF_bit, 4
;Controlador5A.c,90 :: 		CCP3IE_bit  = 0x00;                    //Desabilita interrupcao do periferico CCP
0x002D	0x0021      	MOVLB      1
0x002E	0x1213      	BCF        CCP3IE_bit, 4
;Controlador5A.c,91 :: 		CCP3CON     = 0x05;                    //Configura captura por borda de subida
0x002F	0x3005      	MOVLW      5
0x0030	0x0026      	MOVLB      6
0x0031	0x0093      	MOVWF      CCP3CON
;Controlador5A.c,92 :: 		t2_sig1     = micros() - t1_sig1;      //Guarda o valor do timer1 da segunda captura.
0x0032	0x2157      	CALL       _micros
0x0033	0x0870      	MOVF       R0, 0
0x0034	0x00B8      	MOVWF      _t2_sig1
0x0035	0x0871      	MOVF       R1, 0
0x0036	0x00B9      	MOVWF      _t2_sig1+1
0x0037	0x0872      	MOVF       R2, 0
0x0038	0x00BA      	MOVWF      _t2_sig1+2
0x0039	0x0873      	MOVF       R3, 0
0x003A	0x00BB      	MOVWF      _t2_sig1+3
0x003B	0x0830      	MOVF       _t1_sig1, 0
0x003C	0x02B8      	SUBWF      _t2_sig1, 1
0x003D	0x0831      	MOVF       _t1_sig1+1, 0
0x003E	0x3BB9      	SUBWFB     _t2_sig1+1, 1
0x003F	0x0832      	MOVF       _t1_sig1+2, 0
0x0040	0x3BBA      	SUBWFB     _t2_sig1+2, 1
0x0041	0x0833      	MOVF       _t1_sig1+3, 0
0x0042	0x3BBB      	SUBWFB     _t2_sig1+3, 1
;Controlador5A.c,93 :: 		CCP3IE_bit  = 0x01;                    //Habilita interrupcao do periferico CCP
0x0043	0x0021      	MOVLB      1
0x0044	0x1613      	BSF        CCP3IE_bit, 4
;Controlador5A.c,94 :: 		last_measure = micros();               //guarda o tempo da ultima medida para o controle fail safe
0x0045	0x2157      	CALL       _micros
0x0046	0x0870      	MOVF       R0, 0
0x0047	0x00A4      	MOVWF      _last_measure
0x0048	0x0871      	MOVF       R1, 0
0x0049	0x00A5      	MOVWF      _last_measure+1
0x004A	0x0872      	MOVF       R2, 0
0x004B	0x00A6      	MOVWF      _last_measure+2
0x004C	0x0873      	MOVF       R3, 0
0x004D	0x00A7      	MOVWF      _last_measure+3
;Controlador5A.c,95 :: 		} //end else
L_interrupt17:
L_interrupt16:
0x004E	0x0020      	MOVLB      0
;Controlador5A.c,97 :: 		if(CCP4IF_bit && CCP4CON.B0)            //Interrupcao do modulo CCP4 e modo de captura configurado para borda de subida?
0x004F	0x1E93      	BTFSS      CCP4IF_bit, 5
0x0050	0x2867      	GOTO       L_interrupt20
0x0051	0x0026      	MOVLB      6
0x0052	0x1C1A      	BTFSS      CCP4CON, 0
0x0053	0x2867      	GOTO       L_interrupt20
L__interrupt52:
;Controlador5A.c,99 :: 		CCP4IF_bit  = 0x00;                    //Limpa a flag para nova captura
0x0054	0x0020      	MOVLB      0
0x0055	0x1293      	BCF        CCP4IF_bit, 5
;Controlador5A.c,100 :: 		CCP4IE_bit  = 0x00;                    //Desabilita interrupcao do periferico CCP
0x0056	0x0021      	MOVLB      1
0x0057	0x1293      	BCF        CCP4IE_bit, 5
;Controlador5A.c,101 :: 		CCP4CON     = 0x04;                    //Configura captura por borda de descida
0x0058	0x3004      	MOVLW      4
0x0059	0x0026      	MOVLB      6
0x005A	0x009A      	MOVWF      CCP4CON
;Controlador5A.c,102 :: 		t1_sig2     = micros();                //Guarda o valor do timer1 da primeira captura.
0x005B	0x2157      	CALL       _micros
0x005C	0x0870      	MOVF       R0, 0
0x005D	0x00AC      	MOVWF      _t1_sig2
0x005E	0x0871      	MOVF       R1, 0
0x005F	0x00AD      	MOVWF      _t1_sig2+1
0x0060	0x0872      	MOVF       R2, 0
0x0061	0x00AE      	MOVWF      _t1_sig2+2
0x0062	0x0873      	MOVF       R3, 0
0x0063	0x00AF      	MOVWF      _t1_sig2+3
;Controlador5A.c,103 :: 		CCP4IE_bit  = 0x01;                    //Habilita interrupcao do periferico CCP
0x0064	0x0021      	MOVLB      1
0x0065	0x1693      	BSF        CCP4IE_bit, 5
;Controlador5A.c,104 :: 		} //end if
0x0066	0x288C      	GOTO       L_interrupt21
L_interrupt20:
;Controlador5A.c,105 :: 		else if(CCP4IF_bit)                     //Interrupcao do modulo CCP4?
0x0067	0x0020      	MOVLB      0
0x0068	0x1E93      	BTFSS      CCP4IF_bit, 5
0x0069	0x288C      	GOTO       L_interrupt22
;Controlador5A.c,107 :: 		CCP4IF_bit  = 0x00;                    //Limpa a flag para nova captura
0x006A	0x1293      	BCF        CCP4IF_bit, 5
;Controlador5A.c,108 :: 		CCP4IE_bit  = 0x00;                    //Desabilita interrupcao do periferico CCP
0x006B	0x0021      	MOVLB      1
0x006C	0x1293      	BCF        CCP4IE_bit, 5
;Controlador5A.c,109 :: 		CCP4CON     = 0x05;                    //Configura captura por borda de subida
0x006D	0x3005      	MOVLW      5
0x006E	0x0026      	MOVLB      6
0x006F	0x009A      	MOVWF      CCP4CON
;Controlador5A.c,110 :: 		t2_sig2     = micros() - t1_sig2;      //Guarda o valor do timer1 da segunda captura.
0x0070	0x2157      	CALL       _micros
0x0071	0x0870      	MOVF       R0, 0
0x0072	0x00A8      	MOVWF      _t2_sig2
0x0073	0x0871      	MOVF       R1, 0
0x0074	0x00A9      	MOVWF      _t2_sig2+1
0x0075	0x0872      	MOVF       R2, 0
0x0076	0x00AA      	MOVWF      _t2_sig2+2
0x0077	0x0873      	MOVF       R3, 0
0x0078	0x00AB      	MOVWF      _t2_sig2+3
0x0079	0x082C      	MOVF       _t1_sig2, 0
0x007A	0x02A8      	SUBWF      _t2_sig2, 1
0x007B	0x082D      	MOVF       _t1_sig2+1, 0
0x007C	0x3BA9      	SUBWFB     _t2_sig2+1, 1
0x007D	0x082E      	MOVF       _t1_sig2+2, 0
0x007E	0x3BAA      	SUBWFB     _t2_sig2+2, 1
0x007F	0x082F      	MOVF       _t1_sig2+3, 0
0x0080	0x3BAB      	SUBWFB     _t2_sig2+3, 1
;Controlador5A.c,111 :: 		CCP4IE_bit  = 0x01;                    //Habilita interrupcao do periferico CCP
0x0081	0x0021      	MOVLB      1
0x0082	0x1693      	BSF        CCP4IE_bit, 5
;Controlador5A.c,112 :: 		last_measure = micros();               //guarda o tempo da ultima medida para o controle fail safe
0x0083	0x2157      	CALL       _micros
0x0084	0x0870      	MOVF       R0, 0
0x0085	0x00A4      	MOVWF      _last_measure
0x0086	0x0871      	MOVF       R1, 0
0x0087	0x00A5      	MOVWF      _last_measure+1
0x0088	0x0872      	MOVF       R2, 0
0x0089	0x00A6      	MOVWF      _last_measure+2
0x008A	0x0873      	MOVF       R3, 0
0x008B	0x00A7      	MOVWF      _last_measure+3
;Controlador5A.c,113 :: 		} //end else  */
L_interrupt22:
L_interrupt21:
;Controlador5A.c,114 :: 		} //end interrupt
L_end_interrupt:
L__interrupt65:
0x008C	0x0020      	MOVLB      0
0x008D	0x0821      	MOVF       33, 0
0x008E	0x00F0      	MOVWF      R0
0x008F	0x0820      	MOVF       32, 0
0x0090	0x00F1      	MOVWF      R1
0x0091	0x0009      	RETFIE     %s
; end of _interrupt
_ADC_Init:
;__Lib_ADC.c,19 :: 		
;__Lib_ADC.c,20 :: 		
0x0092	0x30FF      	MOVLW      _ADC_Get_Sample
0x0093	0x0020      	MOVLB      0
0x0094	0x00B4      	MOVWF      _ADC_Get_Sample_Ptr
0x0095	0x30FF      	MOVLW      hi_addr(_ADC_Get_Sample)
0x0096	0x00B5      	MOVWF      _ADC_Get_Sample_Ptr+1
0x0097	0x30FF      	MOVLW      FARG_ADC_Get_Sample_channel
0x0098	0x00B6      	MOVWF      _ADC_Get_Sample_Ptr+2
0x0099	0x30FF      	MOVLW      hi_addr(FARG_ADC_Get_Sample_channel)
0x009A	0x00B7      	MOVWF      _ADC_Get_Sample_Ptr+3
;__Lib_ADC.c,21 :: 		
0x009B	0x30F0      	MOVLW      240
0x009C	0x0021      	MOVLB      1
0x009D	0x009E      	MOVWF      ADCON1
;__Lib_ADC.c,22 :: 		
0x009E	0x019D      	CLRF       ADCON0
;__Lib_ADC.c,23 :: 		
0x009F	0x141D      	BSF        ADON_bit, 0
;__Lib_ADC.c,24 :: 		
L_end_ADC_Init:
0x00A0	0x0008      	RETURN
; end of _ADC_Init
___CC2DW:
;__Lib_System.c,71 :: 		
;__Lib_System.c,73 :: 		
_CC2DL_Loop1:
;__Lib_System.c,74 :: 		
0x00A1	0x0012      	MOVIW      0, 2
;__Lib_System.c,75 :: 		
0x00A2	0x001E      	MOVWI      FSR1++ 
;__Lib_System.c,76 :: 		
0x00A3	0x03F0      	DECF       R0, 1
;__Lib_System.c,77 :: 		
0x00A4	0x1D03      	BTFSS      STATUS, 2
;__Lib_System.c,78 :: 		
0x00A5	0x28A1      	GOTO       _CC2DL_Loop1
;__Lib_System.c,79 :: 		
0x00A6	0x03F1      	DECF       R1, 1
;__Lib_System.c,80 :: 		
0x00A7	0x1D03      	BTFSS      STATUS, 2
;__Lib_System.c,81 :: 		
0x00A8	0x28A1      	GOTO       _CC2DL_Loop1
;__Lib_System.c,83 :: 		
L_end___CC2DW:
0x00A9	0x0008      	RETURN
; end of ___CC2DW
_setup_port:
;setupFunctions.c,3 :: 		void setup_port(){
;setupFunctions.c,5 :: 		CM1CON0       = 0;
0x00AA	0x0022      	MOVLB      2
0x00AB	0x0191      	CLRF       CM1CON0
;setupFunctions.c,6 :: 		CM2CON0       = 0;
0x00AC	0x0193      	CLRF       CM2CON0
;setupFunctions.c,9 :: 		P2BSEL_bit =  1;    //P2BSEL: 1 = P2B function is on RA4
0x00AD	0x149E      	BSF        P2BSEL_bit, 1
;setupFunctions.c,10 :: 		CCP2SEL_bit =  1;   //CCP2SEL:1 = CCP2/P2A function is on RA5
0x00AE	0x141E      	BSF        CCP2SEL_bit, 0
;setupFunctions.c,13 :: 		ANSELA     = 0; //Nenhuma porta analogica
0x00AF	0x0023      	MOVLB      3
0x00B0	0x018C      	CLRF       ANSELA
;setupFunctions.c,14 :: 		ANSELC  = 0x01; //RC0 analogico AN4, ultimo bit do ANSELC.
0x00B1	0x3001      	MOVLW      1
0x00B2	0x008E      	MOVWF      ANSELC
;setupFunctions.c,15 :: 		ADC_Init();     // Initialize ADC module with default settings
0x00B3	0x2092      	CALL       _ADC_Init
;setupFunctions.c,19 :: 		TRISA0_bit = 0; //TX(UART) Nao precisamos setar pois a funcao de UART ja o faz
0x00B4	0x100C      	BCF        TRISA0_bit, 0
;setupFunctions.c,20 :: 		TRISA1_bit = 0; //RX(UART) e LED_ERROR
0x00B5	0x108C      	BCF        TRISA1_bit, 1
;setupFunctions.c,21 :: 		TRISA2_bit = 1; //RADIO INPUT1(CCP3)
0x00B6	0x150C      	BSF        TRISA2_bit, 2
;setupFunctions.c,22 :: 		TRISA3_bit = 1; //MLCR e CALIB_BUTTON
0x00B7	0x158C      	BSF        TRISA3_bit, 3
;setupFunctions.c,23 :: 		TRISA4_bit = 0; //PWM OUTPUT(P2B)
0x00B8	0x120C      	BCF        TRISA4_bit, 4
;setupFunctions.c,24 :: 		TRISA5_bit = 0; //PWM OUTPUT(P2A)
0x00B9	0x128C      	BCF        TRISA5_bit, 5
;setupFunctions.c,28 :: 		TRISC0_bit = 1; //AN4 (LOW BATTERY)
0x00BA	0x140E      	BSF        TRISC0_bit, 0
;setupFunctions.c,29 :: 		TRISC1_bit = 1; //RADIO INPUT2(CCP4)
0x00BB	0x148E      	BSF        TRISC1_bit, 1
;setupFunctions.c,30 :: 		TRISC2_bit = 1; //ERROR FLAG2
0x00BC	0x150E      	BSF        TRISC2_bit, 2
;setupFunctions.c,31 :: 		TRISC3_bit = 1; //ERROR FLAG1
0x00BD	0x158E      	BSF        TRISC3_bit, 3
;setupFunctions.c,32 :: 		TRISC4_bit = 0; //PWM OUTPUT(P1B)
0x00BE	0x120E      	BCF        TRISC4_bit, 4
;setupFunctions.c,33 :: 		TRISC5_bit = 0; //PWM OUTPUT(P1A)
0x00BF	0x128E      	BCF        TRISC5_bit, 5
;setupFunctions.c,37 :: 		GIE_bit    = 0X01;   //Habilita a interrupcao Global
0x00C0	0x178B      	BSF        GIE_bit, 7
;setupFunctions.c,38 :: 		PEIE_bit   = 0X01;   //Habilita a interrupcao por perifericos
0x00C1	0x170B      	BSF        PEIE_bit, 6
;setupFunctions.c,39 :: 		CCP3IE_bit  = 0x01;  //Habilita interrupcoes do modulo CCP3(RADIO INPUT1)
0x00C2	0x1613      	BSF        CCP3IE_bit, 4
;setupFunctions.c,40 :: 		CCP4IE_bit  = 0x01;  //Habilita interrupcoes do modulo CCP4(RADIO INPUT2)
0x00C3	0x1693      	BSF        CCP4IE_bit, 5
;setupFunctions.c,41 :: 		CCP3CON     = 0x05;  //Configura captura por borda de subida
0x00C4	0x3005      	MOVLW      5
0x00C5	0x0026      	MOVLB      6
0x00C6	0x0093      	MOVWF      CCP3CON
;setupFunctions.c,42 :: 		CCP4CON     = 0x05;  //Configura captura por borda de subida
0x00C7	0x3005      	MOVLW      5
0x00C8	0x009A      	MOVWF      CCP4CON
;setupFunctions.c,44 :: 		}
L_end_setup_port:
0x00C9	0x0008      	RETURN
; end of _setup_port
_set_duty_cycle:
;motorsPWM.c,4 :: 		void set_duty_cycle(unsigned int channel, unsigned int duty ){ //funcao responsavel por setar o dutycicle nos PWMS, variando de 0 a 255
;motorsPWM.c,5 :: 		if(channel == 1)
0x00CA	0x3000      	MOVLW      0
0x00CB	0x0020      	MOVLB      0
0x00CC	0x063D      	XORWF      FARG_set_duty_cycle_channel+1, 0
0x00CD	0x1D03      	BTFSS      STATUS, 2
0x00CE	0x28D1      	GOTO       L__set_duty_cycle25
0x00CF	0x3001      	MOVLW      1
0x00D0	0x063C      	XORWF      FARG_set_duty_cycle_channel, 0
L__set_duty_cycle25:
0x00D1	0x1D03      	BTFSS      STATUS, 2
0x00D2	0x28D6      	GOTO       L_set_duty_cycle0
;motorsPWM.c,6 :: 		CCPR1L = duty;
0x00D3	0x083E      	MOVF       FARG_set_duty_cycle_duty, 0
0x00D4	0x0025      	MOVLB      5
0x00D5	0x0091      	MOVWF      CCPR1L
L_set_duty_cycle0:
;motorsPWM.c,7 :: 		if(channel == 2)
0x00D6	0x3000      	MOVLW      0
0x00D7	0x0020      	MOVLB      0
0x00D8	0x063D      	XORWF      FARG_set_duty_cycle_channel+1, 0
0x00D9	0x1D03      	BTFSS      STATUS, 2
0x00DA	0x28DD      	GOTO       L__set_duty_cycle26
0x00DB	0x3002      	MOVLW      2
0x00DC	0x063C      	XORWF      FARG_set_duty_cycle_channel, 0
L__set_duty_cycle26:
0x00DD	0x1D03      	BTFSS      STATUS, 2
0x00DE	0x28E2      	GOTO       L_set_duty_cycle1
;motorsPWM.c,8 :: 		CCPR2L = duty;
0x00DF	0x083E      	MOVF       FARG_set_duty_cycle_duty, 0
0x00E0	0x0025      	MOVLB      5
0x00E1	0x0098      	MOVWF      CCPR2L
L_set_duty_cycle1:
;motorsPWM.c,9 :: 		}
L_end_set_duty_cycle:
0x00E2	0x0008      	RETURN
; end of _set_duty_cycle
_setup_pwms:
;setupFunctions.c,46 :: 		void setup_pwms(){
;setupFunctions.c,47 :: 		T2CON = 0;   //desliga o Timer2, timer responsavel pelos PWMS
0x00E3	0x0020      	MOVLB      0
0x00E4	0x019C      	CLRF       T2CON
;setupFunctions.c,48 :: 		PR2 = 255;
0x00E5	0x30FF      	MOVLW      255
0x00E6	0x009B      	MOVWF      PR2
;setupFunctions.c,51 :: 		CCPTMRS.B1 = 0;    //00 = CCP1 is based off Timer2 in PWM mode
0x00E7	0x0025      	MOVLB      5
0x00E8	0x109E      	BCF        CCPTMRS, 1
;setupFunctions.c,52 :: 		CCPTMRS.B0 = 0;
0x00E9	0x101E      	BCF        CCPTMRS, 0
;setupFunctions.c,55 :: 		PSTR1CON.B0 = 1;   //1 = P1A pin has the PWM waveform with polarity control from CCP1M<1:0>
0x00EA	0x1416      	BSF        PSTR1CON, 0
;setupFunctions.c,56 :: 		PSTR1CON.B1 = 1;   //1 = P1B pin has the PWM waveform with polarity control from CCP1M<1:0>
0x00EB	0x1496      	BSF        PSTR1CON, 1
;setupFunctions.c,57 :: 		PSTR1CON.B2 = 0;   //0 = P1C pin is assigned to port pin
0x00EC	0x1116      	BCF        PSTR1CON, 2
;setupFunctions.c,58 :: 		PSTR1CON.B3 = 0;   //0 = P1D pin is assigned to port pin
0x00ED	0x1196      	BCF        PSTR1CON, 3
;setupFunctions.c,59 :: 		PSTR1CON.B4 = 0;   //Steering Sync bit, 0 = Output steering update occurs at the beginning of the instruction cycle boundary
0x00EE	0x1216      	BCF        PSTR1CON, 4
;setupFunctions.c,60 :: 		CCPR1L  = 0b11111111; //colocando nivel logico alto nas duas saidas para travar os motores
0x00EF	0x30FF      	MOVLW      255
0x00F0	0x0091      	MOVWF      CCPR1L
;setupFunctions.c,61 :: 		CCP1CON = 0b00111100; //see below:
0x00F1	0x303C      	MOVLW      60
0x00F2	0x0093      	MOVWF      CCP1CON
;setupFunctions.c,75 :: 		CCPTMRS.B3 = 0;    //00 = CCP2 is based off Timer2 in PWM mode
0x00F3	0x119E      	BCF        CCPTMRS, 3
;setupFunctions.c,76 :: 		CCPTMRS.B2 = 0;
0x00F4	0x111E      	BCF        CCPTMRS, 2
;setupFunctions.c,79 :: 		PSTR2CON.B0 = 1;   //1 = P1A pin has the PWM waveform with polarity control from CCP1M<1:0>
0x00F5	0x141D      	BSF        PSTR2CON, 0
;setupFunctions.c,80 :: 		PSTR2CON.B1 = 1;   //1 = P1B pin has the PWM waveform with polarity control from CCP1M<1:0>
0x00F6	0x149D      	BSF        PSTR2CON, 1
;setupFunctions.c,81 :: 		PSTR2CON.B2 = 0;   //0 = P1C pin is assigned to port pin
0x00F7	0x111D      	BCF        PSTR2CON, 2
;setupFunctions.c,82 :: 		PSTR2CON.B3 = 0;   //0 = P1D pin is assigned to port pin
0x00F8	0x119D      	BCF        PSTR2CON, 3
;setupFunctions.c,83 :: 		PSTR2CON.B4 = 0;   //Steering Sync bit, 0 = Output steering update occurs at the beginning of the instruction cycle boundary
0x00F9	0x121D      	BCF        PSTR2CON, 4
;setupFunctions.c,84 :: 		CCPR2L  = 0b11111111;  //colocando nivel logico alto nas duas saidas para travar os motores
0x00FA	0x30FF      	MOVLW      255
0x00FB	0x0098      	MOVWF      CCPR2L
;setupFunctions.c,85 :: 		CCP2CON = 0b00111100; //Mesma configuracao do ECCP1
0x00FC	0x303C      	MOVLW      60
0x00FD	0x009A      	MOVWF      CCP2CON
;setupFunctions.c,86 :: 		T2CON = 0b00000100;  //pre scaler =  1
0x00FE	0x3004      	MOVLW      4
0x00FF	0x0020      	MOVLB      0
0x0100	0x009C      	MOVWF      T2CON
;setupFunctions.c,91 :: 		}
L_end_setup_pwms:
0x0101	0x0008      	RETURN
; end of _setup_pwms
_setup_Timer_1:
;setupFunctions.c,101 :: 		void setup_Timer_1(){
;setupFunctions.c,103 :: 		T1CKPS1_bit = 0x00;                        //Prescaller TMR1 1:2, cada bit do timer1 e correspondente a 1 us
0x0102	0x0020      	MOVLB      0
0x0103	0x1298      	BCF        T1CKPS1_bit, 5
;setupFunctions.c,104 :: 		T1CKPS0_bit = 0x01;                        //
0x0104	0x1618      	BSF        T1CKPS0_bit, 4
;setupFunctions.c,105 :: 		TMR1CS1_bit = 0x00;                        //Clock: Fosc/4 = instruction clock
0x0105	0x1398      	BCF        TMR1CS1_bit, 7
;setupFunctions.c,106 :: 		TMR1CS0_bit = 0x00;                        //Clock: Fosc/4 = instruction clock
0x0106	0x1318      	BCF        TMR1CS0_bit, 6
;setupFunctions.c,107 :: 		TMR1ON_bit  = 0x01;                        //Inicia a contagem do Timer1
0x0107	0x1418      	BSF        TMR1ON_bit, 0
;setupFunctions.c,108 :: 		TMR1IE_bit  = 0x01;                        //Habilita interrupcoes de TMR1
0x0108	0x0021      	MOVLB      1
0x0109	0x1411      	BSF        TMR1IE_bit, 0
;setupFunctions.c,109 :: 		TMR1L       = 0x00;                        //zera o Timer1
0x010A	0x0020      	MOVLB      0
0x010B	0x0196      	CLRF       TMR1L
;setupFunctions.c,110 :: 		TMR1H       = 0x00;
0x010C	0x0197      	CLRF       TMR1H
;setupFunctions.c,114 :: 		}
L_end_setup_Timer_1:
0x010D	0x0008      	RETURN
; end of _setup_Timer_1
_pwm_steering:
;motorsPWM.c,10 :: 		void pwm_steering(unsigned int channel,unsigned int port){
;motorsPWM.c,11 :: 		if(channel == 1){
0x010E	0x3000      	MOVLW      0
0x010F	0x0020      	MOVLB      0
0x0110	0x063D      	XORWF      FARG_pwm_steering_channel+1, 0
0x0111	0x1D03      	BTFSS      STATUS, 2
0x0112	0x2915      	GOTO       L__pwm_steering28
0x0113	0x3001      	MOVLW      1
0x0114	0x063C      	XORWF      FARG_pwm_steering_channel, 0
L__pwm_steering28:
0x0115	0x1D03      	BTFSS      STATUS, 2
0x0116	0x2932      	GOTO       L_pwm_steering2
;motorsPWM.c,12 :: 		PSTR1CON.B0 = 0;   //1 = P1A pin is assigned to port pin
0x0117	0x0025      	MOVLB      5
0x0118	0x1016      	BCF        PSTR1CON, 0
;motorsPWM.c,13 :: 		PSTR1CON.B1 = 0;   //1 = P1B pin is assigned to port pin
0x0119	0x1096      	BCF        PSTR1CON, 1
;motorsPWM.c,14 :: 		if(port == 1){
0x011A	0x3000      	MOVLW      0
0x011B	0x0020      	MOVLB      0
0x011C	0x063F      	XORWF      FARG_pwm_steering_port+1, 0
0x011D	0x1D03      	BTFSS      STATUS, 2
0x011E	0x2921      	GOTO       L__pwm_steering29
0x011F	0x3001      	MOVLW      1
0x0120	0x063E      	XORWF      FARG_pwm_steering_port, 0
L__pwm_steering29:
0x0121	0x1D03      	BTFSS      STATUS, 2
0x0122	0x2926      	GOTO       L_pwm_steering3
;motorsPWM.c,15 :: 		P1B = 0;         //port pin stays at low
0x0123	0x120E      	BCF        RC4_bit, 4
;motorsPWM.c,16 :: 		PSTR1CON.B0 = 1; //1 = P1A pin has the PWM waveform
0x0124	0x0025      	MOVLB      5
0x0125	0x1416      	BSF        PSTR1CON, 0
;motorsPWM.c,17 :: 		}
L_pwm_steering3:
;motorsPWM.c,18 :: 		if(port == 2){
0x0126	0x3000      	MOVLW      0
0x0127	0x0020      	MOVLB      0
0x0128	0x063F      	XORWF      FARG_pwm_steering_port+1, 0
0x0129	0x1D03      	BTFSS      STATUS, 2
0x012A	0x292D      	GOTO       L__pwm_steering30
0x012B	0x3002      	MOVLW      2
0x012C	0x063E      	XORWF      FARG_pwm_steering_port, 0
L__pwm_steering30:
0x012D	0x1D03      	BTFSS      STATUS, 2
0x012E	0x2932      	GOTO       L_pwm_steering4
;motorsPWM.c,19 :: 		P1A = 0;         //port pin stays at low
0x012F	0x128E      	BCF        RC5_bit, 5
;motorsPWM.c,20 :: 		PSTR1CON.B1 = 1; //1 = P1B pin has the PWM waveform
0x0130	0x0025      	MOVLB      5
0x0131	0x1496      	BSF        PSTR1CON, 1
;motorsPWM.c,21 :: 		}
L_pwm_steering4:
;motorsPWM.c,22 :: 		}//channel1 if
L_pwm_steering2:
;motorsPWM.c,23 :: 		if(channel == 2){
0x0132	0x3000      	MOVLW      0
0x0133	0x0020      	MOVLB      0
0x0134	0x063D      	XORWF      FARG_pwm_steering_channel+1, 0
0x0135	0x1D03      	BTFSS      STATUS, 2
0x0136	0x2939      	GOTO       L__pwm_steering31
0x0137	0x3002      	MOVLW      2
0x0138	0x063C      	XORWF      FARG_pwm_steering_channel, 0
L__pwm_steering31:
0x0139	0x1D03      	BTFSS      STATUS, 2
0x013A	0x2956      	GOTO       L_pwm_steering5
;motorsPWM.c,24 :: 		PSTR2CON.B0 = 0;   //1 = P2A pin is assigned to port pin
0x013B	0x0025      	MOVLB      5
0x013C	0x101D      	BCF        PSTR2CON, 0
;motorsPWM.c,25 :: 		PSTR2CON.B1 = 0;   //1 = P2B pin is assigned to port pin
0x013D	0x109D      	BCF        PSTR2CON, 1
;motorsPWM.c,26 :: 		if(port == 1){
0x013E	0x3000      	MOVLW      0
0x013F	0x0020      	MOVLB      0
0x0140	0x063F      	XORWF      FARG_pwm_steering_port+1, 0
0x0141	0x1D03      	BTFSS      STATUS, 2
0x0142	0x2945      	GOTO       L__pwm_steering32
0x0143	0x3001      	MOVLW      1
0x0144	0x063E      	XORWF      FARG_pwm_steering_port, 0
L__pwm_steering32:
0x0145	0x1D03      	BTFSS      STATUS, 2
0x0146	0x294A      	GOTO       L_pwm_steering6
;motorsPWM.c,27 :: 		P2B = 0;         //port pin stays at low
0x0147	0x120C      	BCF        RA4_bit, 4
;motorsPWM.c,28 :: 		PSTR2CON.B0 = 1; //1 = P2A pin has the PWM waveform
0x0148	0x0025      	MOVLB      5
0x0149	0x141D      	BSF        PSTR2CON, 0
;motorsPWM.c,29 :: 		}
L_pwm_steering6:
;motorsPWM.c,30 :: 		if(port == 2){
0x014A	0x3000      	MOVLW      0
0x014B	0x0020      	MOVLB      0
0x014C	0x063F      	XORWF      FARG_pwm_steering_port+1, 0
0x014D	0x1D03      	BTFSS      STATUS, 2
0x014E	0x2951      	GOTO       L__pwm_steering33
0x014F	0x3002      	MOVLW      2
0x0150	0x063E      	XORWF      FARG_pwm_steering_port, 0
L__pwm_steering33:
0x0151	0x1D03      	BTFSS      STATUS, 2
0x0152	0x2956      	GOTO       L_pwm_steering7
;motorsPWM.c,31 :: 		P2A = 0;         //port pin stays at low
0x0153	0x128C      	BCF        RA5_bit, 5
;motorsPWM.c,32 :: 		PSTR2CON.B1 = 1; //1 = P2B pin has the PWM waveform
0x0154	0x0025      	MOVLB      5
0x0155	0x149D      	BSF        PSTR2CON, 1
;motorsPWM.c,33 :: 		}
L_pwm_steering7:
;motorsPWM.c,34 :: 		}//channel2 if
L_pwm_steering5:
;motorsPWM.c,36 :: 		}
L_end_pwm_steering:
0x0156	0x0008      	RETURN
; end of _pwm_steering
_micros:
;Controlador5A.c,16 :: 		unsigned long long micros(){
;Controlador5A.c,17 :: 		return  (TMR1H <<8 | TMR1L)* TIMER1_CONST     //cada bit do timer 1 vale 1us
0x0157	0x0020      	MOVLB      0
0x0158	0x0817      	MOVF       TMR1H, 0
0x0159	0x00F1      	MOVWF      R1
0x015A	0x01F0      	CLRF       R0
0x015B	0x0816      	MOVF       TMR1L, 0
0x015C	0x0470      	IORWF       R0, 0
0x015D	0x00F5      	MOVWF      R5
0x015E	0x0871      	MOVF       R1, 0
0x015F	0x00F6      	MOVWF      R6
0x0160	0x3000      	MOVLW      0
0x0161	0x04F6      	IORWF       R6, 1
;Controlador5A.c,18 :: 		+ n_interrupts_timer1*OVERFLOW_CONST; //numero de interrupcoes vezes o valor maximo do Timer 1 (2^16)
0x0162	0x0823      	MOVF       _n_interrupts_timer1+1, 0
0x0163	0x00F3      	MOVWF      R3
0x0164	0x0822      	MOVF       _n_interrupts_timer1, 0
0x0165	0x00F2      	MOVWF      R2
0x0166	0x01F0      	CLRF       R0
0x0167	0x01F1      	CLRF       R1
0x0168	0x0875      	MOVF       R5, 0
0x0169	0x07F0      	ADDWF      R0, 1
0x016A	0x0876      	MOVF       R6, 0
0x016B	0x3DF1      	ADDWFC     R1, 1
0x016C	0x3000      	MOVLW      0
0x016D	0x3DF2      	ADDWFC     R2, 1
0x016E	0x3DF3      	ADDWFC     R3, 1
;Controlador5A.c,19 :: 		}
L_end_micros:
0x016F	0x0008      	RETURN
; end of _micros
_main:
0x0170	0x0020      	MOVLB      0
0x0171	0x01A2      	CLRF       _n_interrupts_timer1
0x0172	0x01A3      	CLRF       35
;Controlador5A.c,250 :: 		void main() {
;Controlador5A.c,251 :: 		OSCCON = 0b01110010; //Coloca o oscillador interno a 8Mz. NAO APAGAR ESSA LINHA (talvez muda-la pra dentro do setup_port)
0x0173	0x3072      	MOVLW      114
0x0174	0x0021      	MOVLB      1
0x0175	0x0099      	MOVWF      OSCCON
;Controlador5A.c,252 :: 		setup_port();
0x0176	0x20AA      	CALL       _setup_port
;Controlador5A.c,253 :: 		setup_pwms();
0x0177	0x20E3      	CALL       _setup_pwms
;Controlador5A.c,254 :: 		setup_Timer_1();
0x0178	0x2102      	CALL       _setup_Timer_1
;Controlador5A.c,257 :: 		pwm_steering(1,2);
0x0179	0x3001      	MOVLW      1
0x017A	0x00BC      	MOVWF      FARG_pwm_steering_channel
0x017B	0x3000      	MOVLW      0
0x017C	0x00BD      	MOVWF      FARG_pwm_steering_channel+1
0x017D	0x3002      	MOVLW      2
0x017E	0x00BE      	MOVWF      FARG_pwm_steering_port
0x017F	0x3000      	MOVLW      0
0x0180	0x00BF      	MOVWF      FARG_pwm_steering_port+1
0x0181	0x210E      	CALL       _pwm_steering
;Controlador5A.c,258 :: 		pwm_steering(2,2);
0x0182	0x3002      	MOVLW      2
0x0183	0x0020      	MOVLB      0
0x0184	0x00BC      	MOVWF      FARG_pwm_steering_channel
0x0185	0x3000      	MOVLW      0
0x0186	0x00BD      	MOVWF      FARG_pwm_steering_channel+1
0x0187	0x3002      	MOVLW      2
0x0188	0x00BE      	MOVWF      FARG_pwm_steering_port
0x0189	0x3000      	MOVLW      0
0x018A	0x00BF      	MOVWF      FARG_pwm_steering_port+1
0x018B	0x210E      	CALL       _pwm_steering
;Controlador5A.c,259 :: 		set_duty_cycle(1, 0);
0x018C	0x3001      	MOVLW      1
0x018D	0x0020      	MOVLB      0
0x018E	0x00BC      	MOVWF      FARG_set_duty_cycle_channel
0x018F	0x3000      	MOVLW      0
0x0190	0x00BD      	MOVWF      FARG_set_duty_cycle_channel+1
0x0191	0x01BE      	CLRF       FARG_set_duty_cycle_duty
0x0192	0x01BF      	CLRF       FARG_set_duty_cycle_duty+1
0x0193	0x20CA      	CALL       _set_duty_cycle
;Controlador5A.c,260 :: 		set_duty_cycle(2, 0);
0x0194	0x3002      	MOVLW      2
0x0195	0x0020      	MOVLB      0
0x0196	0x00BC      	MOVWF      FARG_set_duty_cycle_channel
0x0197	0x3000      	MOVLW      0
0x0198	0x00BD      	MOVWF      FARG_set_duty_cycle_channel+1
0x0199	0x01BE      	CLRF       FARG_set_duty_cycle_duty
0x019A	0x01BF      	CLRF       FARG_set_duty_cycle_duty+1
0x019B	0x20CA      	CALL       _set_duty_cycle
;Controlador5A.c,261 :: 		delay_ms(1000);
0x019C	0x300B      	MOVLW      11
0x019D	0x00FB      	MOVWF      R11
0x019E	0x3026      	MOVLW      38
0x019F	0x00FC      	MOVWF      R12
0x01A0	0x305D      	MOVLW      93
0x01A1	0x00FD      	MOVWF      R13
L_main47:
0x01A2	0x0BFD      	DECFSZ     R13, 1
0x01A3	0x29A2      	GOTO       L_main47
0x01A4	0x0BFC      	DECFSZ     R12, 1
0x01A5	0x29A2      	GOTO       L_main47
0x01A6	0x0BFB      	DECFSZ     R11, 1
0x01A7	0x29A2      	GOTO       L_main47
0x01A8	0x0000      	NOP
0x01A9	0x0000      	NOP
;Controlador5A.c,262 :: 		t2_sig2 = 15000;
0x01AA	0x3098      	MOVLW      152
0x01AB	0x0020      	MOVLB      0
0x01AC	0x00A8      	MOVWF      _t2_sig2
0x01AD	0x303A      	MOVLW      58
0x01AE	0x00A9      	MOVWF      _t2_sig2+1
0x01AF	0x01AA      	CLRF       _t2_sig2+2
0x01B0	0x01AB      	CLRF       _t2_sig2+3
;Controlador5A.c,263 :: 		t2_sig1 = 15000;
0x01B1	0x3098      	MOVLW      152
0x01B2	0x00B8      	MOVWF      _t2_sig1
0x01B3	0x303A      	MOVLW      58
0x01B4	0x00B9      	MOVWF      _t2_sig1+1
0x01B5	0x01BA      	CLRF       _t2_sig1+2
0x01B6	0x01BB      	CLRF       _t2_sig1+3
;Controlador5A.c,265 :: 		while(1){
L_main48:
0x01B7	0x0020      	MOVLB      0
;Controlador5A.c,267 :: 		pwm_steering(2,2);
0x01B8	0x3002      	MOVLW      2
0x01B9	0x00BC      	MOVWF      FARG_pwm_steering_channel
0x01BA	0x3000      	MOVLW      0
0x01BB	0x00BD      	MOVWF      FARG_pwm_steering_channel+1
0x01BC	0x3002      	MOVLW      2
0x01BD	0x00BE      	MOVWF      FARG_pwm_steering_port
0x01BE	0x3000      	MOVLW      0
0x01BF	0x00BF      	MOVWF      FARG_pwm_steering_port+1
0x01C0	0x210E      	CALL       _pwm_steering
;Controlador5A.c,268 :: 		set_duty_cycle(2, 0);
0x01C1	0x3002      	MOVLW      2
0x01C2	0x0020      	MOVLB      0
0x01C3	0x00BC      	MOVWF      FARG_set_duty_cycle_channel
0x01C4	0x3000      	MOVLW      0
0x01C5	0x00BD      	MOVWF      FARG_set_duty_cycle_channel+1
0x01C6	0x01BE      	CLRF       FARG_set_duty_cycle_duty
0x01C7	0x01BF      	CLRF       FARG_set_duty_cycle_duty+1
0x01C8	0x20CA      	CALL       _set_duty_cycle
;Controlador5A.c,269 :: 		delay_ms(1000);
0x01C9	0x300B      	MOVLW      11
0x01CA	0x00FB      	MOVWF      R11
0x01CB	0x3026      	MOVLW      38
0x01CC	0x00FC      	MOVWF      R12
0x01CD	0x305D      	MOVLW      93
0x01CE	0x00FD      	MOVWF      R13
L_main50:
0x01CF	0x0BFD      	DECFSZ     R13, 1
0x01D0	0x29CF      	GOTO       L_main50
0x01D1	0x0BFC      	DECFSZ     R12, 1
0x01D2	0x29CF      	GOTO       L_main50
0x01D3	0x0BFB      	DECFSZ     R11, 1
0x01D4	0x29CF      	GOTO       L_main50
0x01D5	0x0000      	NOP
0x01D6	0x0000      	NOP
;Controlador5A.c,270 :: 		pwm_steering(2,2);
0x01D7	0x3002      	MOVLW      2
0x01D8	0x0020      	MOVLB      0
0x01D9	0x00BC      	MOVWF      FARG_pwm_steering_channel
0x01DA	0x3000      	MOVLW      0
0x01DB	0x00BD      	MOVWF      FARG_pwm_steering_channel+1
0x01DC	0x3002      	MOVLW      2
0x01DD	0x00BE      	MOVWF      FARG_pwm_steering_port
0x01DE	0x3000      	MOVLW      0
0x01DF	0x00BF      	MOVWF      FARG_pwm_steering_port+1
0x01E0	0x210E      	CALL       _pwm_steering
;Controlador5A.c,271 :: 		set_duty_cycle(2, 150);
0x01E1	0x3002      	MOVLW      2
0x01E2	0x0020      	MOVLB      0
0x01E3	0x00BC      	MOVWF      FARG_set_duty_cycle_channel
0x01E4	0x3000      	MOVLW      0
0x01E5	0x00BD      	MOVWF      FARG_set_duty_cycle_channel+1
0x01E6	0x3096      	MOVLW      150
0x01E7	0x00BE      	MOVWF      FARG_set_duty_cycle_duty
0x01E8	0x01BF      	CLRF       FARG_set_duty_cycle_duty+1
0x01E9	0x20CA      	CALL       _set_duty_cycle
;Controlador5A.c,272 :: 		delay_ms(2000);
0x01EA	0x3015      	MOVLW      21
0x01EB	0x00FB      	MOVWF      R11
0x01EC	0x304B      	MOVLW      75
0x01ED	0x00FC      	MOVWF      R12
0x01EE	0x30BE      	MOVLW      190
0x01EF	0x00FD      	MOVWF      R13
L_main51:
0x01F0	0x0BFD      	DECFSZ     R13, 1
0x01F1	0x29F0      	GOTO       L_main51
0x01F2	0x0BFC      	DECFSZ     R12, 1
0x01F3	0x29F0      	GOTO       L_main51
0x01F4	0x0BFB      	DECFSZ     R11, 1
0x01F5	0x29F0      	GOTO       L_main51
0x01F6	0x0000      	NOP
;Controlador5A.c,273 :: 		}
0x01F7	0x29B7      	GOTO       L_main48
;Controlador5A.c,274 :: 		}
L_end_main:
0x01F8	0x29F8      	GOTO       $+0
; end of _main
Symbol List:
//** Routines locations **
//ADDRESS    SIZE    PROCEDURE
//----------------------------------------------
0x0004     [142]    _interrupt
0x0092      [15]    _ADC_Init
0x00A1       [9]    ___CC2DW
0x00AA      [32]    _setup_port
0x00CA      [25]    _set_duty_cycle
0x00E3      [31]    _setup_pwms
0x0102      [12]    _setup_Timer_1
0x010E      [73]    _pwm_steering
0x0157      [25]    _micros
0x0170     [137]    _main
//** Variables locations ** 
//ADDRESS    SIZE    VARIABLE
//----------------------------------------------
0x0000       [1]    INDF0
0x0001       [1]    INDF1
0x0003       [1]    STATUS
0x0004       [1]    FSR0L
0x0005       [1]    FSR0H
0x0006       [1]    FSR1L
0x0007       [1]    FSR1H
0x000A       [1]    PCLATH
0x000B       [0]    PEIE_bit
0x000B       [0]    GIE_bit
0x000C       [0]    RA4_bit
0x000C       [0]    RA5_bit
0x000E       [0]    RC4_bit
0x000E       [0]    RC5_bit
0x0011       [0]    TMR1IF_bit
0x0013       [0]    CCP4IF_bit
0x0013       [0]    CCP3IF_bit
0x0016       [1]    TMR1L
0x0017       [1]    TMR1H
0x0018       [0]    TMR1CS1_bit
0x0018       [0]    T1CKPS0_bit
0x0018       [0]    TMR1CS0_bit
0x0018       [0]    T1CKPS1_bit
0x0018       [0]    TMR1ON_bit
0x001B       [1]    PR2
0x001C       [1]    T2CON
0x0022       [2]    _n_interrupts_timer1
0x0024       [4]    _last_measure
0x0028       [4]    _t2_sig2
0x002C       [4]    _t1_sig2
0x0030       [4]    _t1_sig1
0x0034       [4]    _ADC_Get_Sample_Ptr
0x0038       [4]    _t2_sig1
0x003C       [2]    FARG_pwm_steering_channel
0x003C       [2]    FARG_set_duty_cycle_channel
0x003E       [2]    FARG_pwm_steering_port
0x003E       [2]    FARG_set_duty_cycle_duty
0x0070       [1]    R0
0x0071       [1]    R1
0x0072       [1]    R2
0x0073       [1]    R3
0x0074       [1]    R4
0x0075       [1]    R5
0x0076       [1]    R6
0x0077       [1]    R7
0x0078       [1]    R8
0x0079       [1]    R9
0x007A       [1]    R10
0x007B       [1]    R11
0x007C       [1]    R12
0x007D       [1]    R13
0x007E       [1]    R14
0x007F       [1]    R15
0x008C       [0]    TRISA4_bit
0x008C       [0]    TRISA5_bit
0x008C       [0]    TRISA3_bit
0x008C       [0]    TRISA0_bit
0x008C       [0]    TRISA1_bit
0x008C       [0]    TRISA2_bit
0x008E       [0]    TRISC4_bit
0x008E       [0]    TRISC0_bit
0x008E       [0]    TRISC5_bit
0x008E       [0]    TRISC1_bit
0x008E       [0]    TRISC2_bit
0x008E       [0]    TRISC3_bit
0x0091       [0]    TMR1IE_bit
0x0093       [0]    CCP4IE_bit
0x0093       [0]    CCP3IE_bit
0x0099       [1]    OSCCON
0x009D       [0]    ADON_bit
0x009D       [1]    ADCON0
0x009E       [1]    ADCON1
0x0111       [1]    CM1CON0
0x0113       [1]    CM2CON0
0x011E       [0]    CCP2SEL_bit
0x011E       [0]    P2BSEL_bit
0x018C       [1]    ANSELA
0x018E       [1]    ANSELC
0x0291       [1]    CCPR1L
0x0293       [1]    CCP1CON
0x0296       [1]    PSTR1CON
0x0298       [1]    CCPR2L
0x029A       [1]    CCP2CON
0x029D       [1]    PSTR2CON
0x029E       [1]    CCPTMRS
0x0313       [1]    CCP3CON
0x031A       [1]    CCP4CON
//** Label List: ** 
//----------------------------------------------
  L_failSafeCheck0
  L_PulseIn11
  L_PulseIn12
  L_PulseIn13
  L_PulseIn14
  L_PulseIn15
  L_PulseIn16
  L_PulseIn17
  L_PulseIn18
  L_PulseIn19
  L_rotateMotor110
  L_rotateMotor111
  L_interrupt12
  L_interrupt13
  L_interrupt14
  L_interrupt15
  L_interrupt16
  L_interrupt17
  L_interrupt18
  L_interrupt19
  L_interrupt20
  L_interrupt21
  L_interrupt22
  L_error_led_blink23
  L_error_led_blink24
  L_error_led_blink25
  L_error_led_blink26
  L_error_led_blink27
  L_calibration28
  L_calibration29
  L_calibration30
  L_calibration31
  L_calibration32
  L_calibration33
  L_calibration34
  L_calibration35
  L_calibration36
  L_calibration37
  L_calibration38
  L_calibration39
  L_calibration40
  L_calibration41
  L_calibration42
  L_calibration43
  L_read_eeprom_signals_data44
  L_read_eeprom_signals_data45
  L_print_signal_received46
  L_main47
  L_main48
  L_main49
  L_main50
  L_main51
  L__interrupt52
  L__interrupt53
  L_end_micros
  _micros
  L_end_failSafeCheck
  _failSafeCheck
  L__failSafeCheck56
  L_end_PulseIn1
  _PulseIn1
  L__PulseIn158
  L__PulseIn159
  L__PulseIn160
  L_end_rotateMotor1
  _rotateMotor1
  L__rotateMotor162
  L__rotateMotor163
  L_end_interrupt
  _interrupt
  L__interrupt65
  L_end_error_led_blink
  _error_led_blink
  L__error_led_blink67
  L_end_calibration
  _calibration
  L__calibration69
  L__calibration70
  L__calibration71
  L__calibration72
  L__calibration73
  L__calibration74
  L_end_read_eeprom_signals_data
  _read_eeprom_signals_data
  L_end_print_signal_received
  _print_signal_received
  L_end_main
  _main
  L_set_duty_cycle0
  L_set_duty_cycle1
  L_pwm_steering2
  L_pwm_steering3
  L_pwm_steering4
  L_pwm_steering5
  L_pwm_steering6
  L_pwm_steering7
  L_rotateMotors8
  L_rotateMotors9
  L_rotateMotors10
  L_rotateMotors11
  L_rotateMotors12
  L_rotateMotors13
  L_rotateMotors14
  L_rotateMotors15
  L_rotateMotors16
  L_rotateMotors17
  L_rotateMotors18
  L_rotateMotors19
  L_rotateMotors20
  L_rotateMotors21
  L__rotateMotors22
  L__rotateMotors23
  L_end_set_duty_cycle
  _set_duty_cycle
  L__set_duty_cycle25
  L__set_duty_cycle26
  L_end_pwm_steering
  _pwm_steering
  L__pwm_steering28
  L__pwm_steering29
  L__pwm_steering30
  L__pwm_steering31
  L__pwm_steering32
  L__pwm_steering33
  L_end_map
  _map
  L_end_rotateMotors
  _rotateMotors
  L__rotateMotors36
  L__rotateMotors37
  L__rotateMotors38
  L__rotateMotors39
  L__rotateMotors40
  L__rotateMotors41
  L__rotateMotors42
  L__rotateMotors43
  L__rotateMotors44
  L__rotateMotors45
  L_setup_UART0
  L_end_setup_port
  _setup_port
  L_end_setup_pwms
  _setup_pwms
  L_end_setup_UART
  _setup_UART
  L_end_setup_Timer_1
  _setup_Timer_1
  L_ADC_Get_Sample0
  L_ADC_Get_Sample1
  L_end_ADC_Init
  _ADC_Init
  L_end_ADC_Get_Sample
  _ADC_Get_Sample
  L_end_ADC_Read
  _ADC_Read
  L_CA2A_Loop
  L_CA2AW_Loop
  L_CS2S_Loop
  L_CS2S_End
  L_FZinS_Loop
  L_FZinS_End
  _CC2D_Loop1
  _CC2DL_Loop1
  L_end_____DoIFC
  _____DoIFC
  L_end___CA2A
  ___CA2A
  L_end___CA2AW
  ___CA2AW
  L_end___CS2S
  ___CS2S
  L_end___FZinS
  ___FZinS
  L_end___CC2D
  ___CC2D
  L_end___CC2DW
  ___CC2DW
  L_end_Swap
  _Swap
  L_failSafeCheck0
  L_PulseIn11
  L_PulseIn12
  L_PulseIn13
  L_PulseIn14
  L_PulseIn15
  L_PulseIn16
  L_PulseIn17
  L_PulseIn18
  L_PulseIn19
  L_rotateMotor110
  L_rotateMotor111
  L_interrupt12
  L_interrupt13
  L_interrupt14
  L_interrupt15
  L_interrupt16
  L_interrupt17
  L_interrupt18
  L_interrupt19
  L_interrupt20
  L_interrupt21
  L_interrupt22
  L_error_led_blink23
  L_error_led_blink24
  L_error_led_blink25
  L_error_led_blink26
  L_error_led_blink27
  L_calibration28
  L_calibration29
  L_calibration30
  L_calibration31
  L_calibration32
  L_calibration33
  L_calibration34
  L_calibration35
  L_calibration36
  L_calibration37
  L_calibration38
  L_calibration39
  L_calibration40
  L_calibration41
  L_calibration42
  L_calibration43
  L_read_eeprom_signals_data44
  L_read_eeprom_signals_data45
  L_print_signal_received46
  L_main47
  L_main48
  L_main49
  L_main50
  L_main51
  L__interrupt52
  L__interrupt53
  L_end_micros
  _micros
  L_end_failSafeCheck
  _failSafeCheck
  L__failSafeCheck56
  L_end_PulseIn1
  _PulseIn1
  L__PulseIn158
  L__PulseIn159
  L__PulseIn160
  L_end_rotateMotor1
  _rotateMotor1
  L__rotateMotor162
  L__rotateMotor163
  L_end_interrupt
  _interrupt
  L__interrupt65
  L_end_error_led_blink
  _error_led_blink
  L__error_led_blink67
  L_end_calibration
  _calibration
  L__calibration69
  L__calibration70
  L__calibration71
  L__calibration72
  L__calibration73
  L__calibration74
  L_end_read_eeprom_signals_data
  _read_eeprom_signals_data
  L_end_print_signal_received
  _print_signal_received
  L_end_main
  _main
